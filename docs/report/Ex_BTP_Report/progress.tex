\chapter{Work Progress}
\label{chap:work}
\setlength{\parskip}{1.5mm}
%\setlength{\baselineskip}{1.4mm}
\section{Verifying the Algorithm in MATLAB}
\subsection{Model of Non-Linear Dynamic System}
A schematic diagram of the compound triple-pendulum system is shown in Figure 5.1.The bars of the pendulum have significant mass so that it can be modeled as a compound pendulum. Damping factors were also included in the model for higher degree of chaos and non-linearity in the system.\\ 
Each bar ${i}$ is defined by a set of four parameters: 

${m_{i}}$, the mass of the bar,

${l_{i}}$, the length of the bar,

${I_{i}}$, the moment of inertia of the bar and

${k_{i}}$, the damping coefficient of the bar rotating about it's upper joint.\\                                                                              
The position and velocity of the bars are defined by the six system state variables: $\theta$\textsubscript{1}, $\theta$\textsubscript{2}, $\theta$\textsubscript{3}, ${\dot{\theta\textsubscript{1}}}$, ${\dot{\theta\textsubscript{2}}}$, ${\dot{\theta\textsubscript{3}}}$


\begin{figure}[H]
\begin{subfigure}{0.5\textwidth}
\includegraphics[width=1.1\linewidth]{ball.jpg}
\caption{Chaotic motion of a bouncing ball}\label{fig:ball}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\includegraphics[width=0.8\linewidth]{pendulum.jpg}
\caption{Schematic Diagram of Triple Pendulum}\label{fig:pendulum}
\end{subfigure}
\caption{Examples of Non-Linear Dynamic systems}\label{fig:image1}

\end{figure}
\begin{figure}[h]
\begin{subfigure}{0.5\textwidth}
\includegraphics[width=0.8\linewidth]{param.jpg}
\caption{Table 1}\label{fig:param}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\includegraphics[width=0.8\linewidth]{ic.jpg}
\caption{Table 2}\label{fig:ic}
\end{subfigure}
\caption{Parameters \& Initial Conditions for the Initial Value Problem}\label{fig:image2}
\end{figure}


\subsection{Simulation of Compound Triple Pendulum}
This compound triple-pendulum model has been simulated using MATLAB using approximate differential equations describing the random motions. The parameters and initial conditions of the ODEs are given in Table 1 and Table 2 respectively. For the simulation, numerical methods were used to solve the state space model of the differential equations and the values corresponding to the angular position of the bars were obtained within a certain duration of time with a predefined precision. This generates the mapping values for the encryption module.

\begin{figure}[H]
\centering
\includegraphics[width=16cm]{diff1.jpg}
\caption{Differential Equation for ${\theta\textsubscript{1}}$}\label{fig:diff1}
\end{figure}


\begin{figure}[H]
\centering
\includegraphics[width=16.5cm]{diff2.jpg}
\caption{Differential Equation for ${\theta\textsubscript{2}}$}\label{fig:diff2}
\end{figure}


\begin{figure}[H]
\centering
\includegraphics[width=16.5cm]{diff3.jpg}
\caption{Differential Equation for ${\theta\textsubscript{3}}$}\label{fig:diff3}
\end{figure}
\vfill

The above equations can be simlified as follows:
\begin{align}
\begin{split}
\ddot{\theta_{1}}^{(t+1)} = f_{1}(\theta^{(t)}_{1}, \theta^{(t)}_{2}, \theta^{(t)}_{3},\dot{\theta_{1}}^{(t)},\dot{\theta_{2}}^{(t)}, \dot{\theta_{3}}^{(t)}) \\
\ddot{\theta_{2}}^{(t+1)} = f_{2}(\theta^{(t)}_{1}, \theta^{(t)}_{2}, \theta^{(t)}_{3},\dot{\theta_{1}}^{(t)},\dot{\theta_{2}}^{(t)}, \dot{\theta_{3}}^{(t)})\\
\ddot{\theta_{3}}^{(t+1)} = f_{3}(\theta^{(t)}_{1}, \theta^{(t)}_{2}, \theta^{(t)}_{3},\dot{\theta_{1}}^{(t)},\dot{\theta_{2}}^{(t)}, \dot{\theta_{3}}^{(t)})\\  
\end{split}
\end{align}
The three values $\ddot{\theta_{1}},\ddot{\theta_{2}},\ddot{\theta_{3}}$ are calulated using the above equations.
The differential equations are solved numerically using the following equations by iterating for t = 0 to N where $N=\frac{T}{\Delta t}$:
\begin{align}
\begin{split}
\theta^{(t+1)}_{1} \leftarrow \theta^{(t)}_{1} + \dot{\theta_{1}}^{(t+1)}\Delta t \\
\theta^{(t+1)}_{1} \leftarrow \theta^{(t)}_{1} + \dot{\theta_{1}}^{(t+1)}\Delta t \\
\theta^{(t+1)}_{1} \leftarrow \theta^{(t)}_{1} + \dot{\theta_{1}}^{(t+1)}\Delta t \\  
\end{split}
\end{align}

\begin{align}
\begin{split}
\dot{\theta_{1}}^{(t+1)} \leftarrow \dot{\theta_{1}}^{(t)} + \ddot{\theta_{1}}^{(t+1)}\Delta t \\
\dot{\theta_{2}}^{(t+1)} \leftarrow \dot{\theta_{2}}^{(t)} + \ddot{\theta_{2}}^{(t+1)}\Delta t \\
\dot{\theta_{3}}^{(t+1)} \leftarrow \dot{\theta_{3}}^{(t)} + \ddot{\theta_{3}}^{(t+1)}\Delta t \\  
\end{split}
\end{align}
Store the values of $\theta$ in a vector $y$ such that\\
$\textbf{y} = \{\theta^{(0)}_{i},\theta^{(1)}_{i},\theta^{(2)}_{i}, ... ,\theta^{(N-1)}_{i}\}$ for $i = 1,2,3$ where $N=\frac{T}{\Delta t}$\\
Normalize the values of y in the range $[0,2\pi]$ (or $[-\pi,\pi]$) to get\\ 
$\hat{\textbf{y}}^{i} = \{\hat{\theta}^{(0)}_{i},\hat{\theta}^{(1)}_{i},\hat{\theta}^{(2)}_{i}, ... ,\hat{\theta}^{(N-1)}_{i}\}$ for  $i = 1,2,3$
where $\hat{\theta}^{(t)}_{i} = \theta^{(t)}_{i} - \floor{\frac{\theta^{(t)}_{i}}{2\pi}}\times 2\pi$\\
The three state variable value can be combined using a one-one function $F$, such that $\hat{\textbf{y}}  = F(\hat{\textbf{y}}^{1},\hat{\textbf{y}}^{2},\hat{\textbf{y}}^{3})$ which is also normalized. For simplicity, we use $\hat{\textbf{y}} = \hat{\textbf{y}}^{3}$ here.

\subsubsection{Simulation Results}
These are some of the observations from the simulation of the triple-pendulum model for a duration of t = 0 to t = 10 seconds with $\Delta$t = 0.001 :\\
(i) Initial conditions are same as given in Table 1 \& 2:\\
 
\begin{figure}[H]
\begin{subfigure}{0.5\textwidth}
\includegraphics[width=1\linewidth]{theta.jpg}
\caption{Plot of ${\theta}$ vs Time}\label{fig:theta}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\includegraphics[width=1\linewidth]{theta_norm.jpg}
\caption{Plot of Normalized ${\theta}$ vs Time}\label{fig:theta_norm}
\end{subfigure}
\caption{Motion of Triple-Pendulum for t = 0 to t = 10 sec}\label{fig:image3}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{trajectory.jpg}
\caption{Plot of Motion of Triple-Pendulum}\label{fig:trajectory}
\end{figure}


\subsection{Encryption - Decryption}
Our approach is to convert the plain-text of $M$ characters into ascii format and  map the values to the intervals partitioned from the range of state variable values of the triple-pendulum motion simulated within a specific duration of time for a particular set of parameters and initial conditions. The initial conditions and parameters of the different equation forms a part of the private key. The differential equations were numerically integrated to get the state variable values $\theta_{1},\theta_{2},\theta_{3}$ followed by normalization of the values in the range $[0,2\pi]$ or $[-\pi,\pi]$. Then using Baptista-type method, the entire range of the normalized chaotic function $[\hat{y}_{min},\hat{y}_{max}]$ was partitioned into a number of intervals equal to the number of characters($N_{c}$). Each character in the plain-text is then mapped to a specific interval($k$) and then to a time point ($i$) randomly selecting from that interval. We have used a permutation map $\pi(k)$ for mapping interval id to the character's ascii value.

\begin{algorithm}
%\DontPrintSemicolon % Some LaTeX compilers require you to us\dontprintsemicolon    instead
\KwIn{$\hat{\textbf{y}}$, \textbf{P} , $N_{c}$, $\eta$}
\KwOut{\textbf{C}}
Initialize D = \{\}\\
Find $\hat{y}_{max} = \max_{1 \leq i \leq N}(\hat{y}_{i})$ , $\hat{y}_{min}=\min_{1 \leq i \leq N}(\hat{y}_{i})$\\
Calculate $\epsilon = \frac{(\hat{y}_{max} - \hat{y}_{min})}{N_{c}}$\\
For each $\hat{y}_{i}$ in $\hat{\textbf{y}}$ \linebreak
 Calculate $k = \floor{\frac{\hat{y}_{i}}{\epsilon}}$\linebreak
 $D(\pi(k)) \leftarrow D(\pi(k)) \cup \{i\}$\\
For $m = 1$ to $M$\linebreak
 Initialize $j = 1$, $p = \textbf{P}(m)$ \linebreak
 Calculate $\hat{p} = ASCII(p)$, $l = size(D(\pi(\hat{p})))$ \linebreak
 Generate random number r \linebreak
 While $r \leq \eta $, do $j=(j+1) \% l$ else  $ \textbf{C}(m) = D(\pi(\hat{p}), j)$\\
Return \textbf{C}
\caption{Encryption}
\label{algo:encrypt}
\end{algorithm}

\begin{figure}[H]
\centering
\includegraphics[width=10cm]{crypto.jpg}
\caption{Working Principle of a Symmetric Cryptosystem}\label{fig:crypto}
\end{figure}

On the decryption module, the interval in which the encrypted value lies is computed from the generated motion of the triple-pendulum for the same key. Applying inverse permutation map ($\pi^{-1}(k)$) the corresponding index is calculated which would then refer to the ascii converted clear-text($\tilde{\textbf{P}}$). Converting them into characters, the message can be decoded.\\

\begin{algorithm}
\DontPrintSemicolon % Some LaTeX compilers require you to use\dontprintsemicolon    instead
\KwIn{$\hat{\textbf{y}}$,\textbf{C}}
\KwOut{$\tilde{\textbf{P}}$}
Find $\hat{y}_{max} = \max_{1 \leq i \leq N}(\hat{y}_{i})$ , $\hat{y}_{min}=\min_{1 \leq i \leq N}(\hat{y}_{i})$\\
Calculate $\epsilon = \frac{(\hat{y}_{max} - \hat{y}_{min})}{N_{c}}$\\
For $m = 1$ to $M$\linebreak
 Initialize $c = \textbf{C}(m)$ \linebreak
 Calculate $\hat{k} = \floor{\frac{\hat{y}_{c}}{\epsilon}}$\linebreak 
 Compute $ k = \pi^{-1}(\hat{k})$\linebreak
 $\tilde{\textbf{P}}(m) \leftarrow CHAR(k)$\\
Return $\tilde{\textbf{P}}$
\caption{Decryption}
\label{algo:decrypt}
\end{algorithm}

\begin{figure}[H]
\centering
\includegraphics[width=16cm]{Dataflow.jpg}
\caption{Encryption-Decryption Strategy}\label{fig:Dataflow}
\end{figure}



\section{Key Generation}
It is observed that for certain specific parameters or initial conditions, the motion of the bars of the triple-pendulum shows periodic nature after a certain span of time. Hence there is a need to eliminate those parameters or initial conditions for which the motion is periodic as the periodic nature breaks the chaotic behavior of the system. For that a test for periodicity was employed to extract the prominent period of the signal using statistical analysis on the spectrum of the signal. The test used is known as {\bf{\em Fisher's g-statistic test}} (see [11]). This method is based on the test of significance of the periodic components of the signal derived from its periodogram. 

A periodogram is used to identify the hidden periods (or frequencies) of a time series. This is a helpful tool for identifying the dominant periodic behavior in a series. The periodogram provides a measure of the relative importance of possible frequency values that can explain the oscillation pattern of the observed data.

The periodogram estimate of the Power Spectral Density of a signal $x_{L}(n)$ of length $L$ is defined as
\begin{equation}
 P_{xx}(f) = \frac{1}{LF_{s}} \mid \sum_{n=0}^{L-1} x_{L}(n)e^{-j2\pi fn/F_{s}} \mid^2
\end{equation}

where $F_{s}$ is the sampling frequency.
The computation of $P_{xx}(f)$ can be performed only at a finite number of discrete frequency points given by
\begin{equation}
 f_{k} = \frac{kF_{s}}{N} , k = 0,1, ... , N-1 
\end{equation}
Fisher's g-statistic is defined as the ratio of the maximum periodogram value($P_{xx}(f_{k})$ or $I(\omega_{k})$) to the sum of all periodogram values of the signal.
\begin{equation}
    g = \frac{\max_{k} I(\omega_{k})}{\sum_{k=1}^{[N/2]}I(\omega_{k})}  
\end{equation}
where $I(\omega_{k})$ are the periodogram values. Using the value of g, we are able to calculate the dominant periods of the signal as shown in [11].

The key of this symmetric cryptosystem includes the parameters, initial conditions, time duration, time step, minimum value of $\hat{\textbf{y}}$ and $\epsilon$.\\
$K=\{\theta^{(0)}_{1},\theta^{(0)}_{2},\theta^{(0)}_{3},\dot{\theta}^{(0)}_{1},\dot{\theta}^{(0)}_{2},\dot{\theta}^{(0)}_{3}, m_{1},m_{2},m_{3}, l_{1},l_{2},l_{3}, I_{1},I_{2},I_{3}, k_{1},k_{2},k_{3}, g, \hat{y}_{min}, \hat{y}_{min}/\epsilon \}$
\begin{figure}[H]
\centering
\includegraphics[width=0.5\linewidth]{periodogram.jpg}
\caption{Periodogram Plot for ${\theta}$}\label{fig:periodogram}
\end{figure}


\begin{figure}[H]
\begin{subfigure}{0.5\textwidth}
\includegraphics[width=1\linewidth]{auto_corr1.jpg}
\caption{Plot of Circular Auto-Correlation for ${\theta_{1}}$}\label{fig:cir_auto1}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\includegraphics[width=1\linewidth]{period1.jpg}
\caption{Plot of Periodicity for ${\theta_{1}}$}\label{fig:period1}
\end{subfigure}
\caption{Periodic Properties of ${\theta_{1}}$}\label{fig:image4}
\end{figure}

\begin{figure}[H]
\begin{subfigure}{0.5\textwidth}
\includegraphics[width=1\linewidth]{auto_corr3.jpg}
\caption{Plot of Circular Auto-Correlation for ${\theta_{3}}$}\label{fig:cir_auto3}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\includegraphics[width=1\linewidth]{period3.jpg}
\caption{Plot of Periodicity for ${\theta_{3}}$}\label{fig:period3}
\end{subfigure}
\caption{Periodic Properties of ${\theta_{3}}$}\label{fig:image5}
\end{figure}

From the figures 5.8 \& 5.9 , it is observed that there is peak at 1700 (seconds/Cycle) for $\theta_{1}$ whereas no such peak occurs for $\theta_{3}$. Thus $\theta_{1}$ is periodic in nature. The values obtained from the periodicity test and plots of circular auto-correlation clearly differentiates the parameters and initial values which leads to periodic nature of the motion and those which lead to non-periodic nature of the motion. Thus by iterating through all possibles values of the parameters and checking likewise for non-periodic nature, a set of keys was generated and stored. 


\section{FPGA Implementation}
The complete design has been implemented at Register-Transfer Level (RTL) in {\bf SystemVerilog HDL} and the target device chosen is Digilent Nexys Board with {\bf Xilinx Artix-7 FPGA}. The synthesis tool used is Xilinx Synthesis Tool (XST). The following diagram shows the implementation plan for the design :
% \begin{center}
\begin{figure}[H]
\centering
\resizebox{10cm}{10cm}{
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=5cm, semithick]
  %\tikyle{every state}=[draw=none,text=black]
    
  \node[state] (A)                         {\begin{tabular}{c}$Control$\\$Unit$\end{tabular}};
  \node[state] (C) [above of=A]            {\begin{tabular}{c}$Ethernet$\\$\&$\\$USB$ $ Interface$\\$Module$\end{tabular}};
  \node[state] (B) [right of=C]      {\begin{tabular}{c}$I/O$\\$Ports$\end{tabular}};
  \node[state] (D) [below right of=A]      {\begin{tabular}{c}$LUT2$\\$Mapping$ $of$\\$Plaintext$ $to$\\$Ciphertext$\end{tabular}};
  \node[state] (E) [below left of=A]       {\begin{tabular}{c}$LUT1$\\$Various$\\$Constants$\end{tabular}};
  \node[state] (F) [below of = A]           {\begin{tabular}{c}$Arithmetic$\\$\&$ $Logic$\\$Unit$\end{tabular}};

\path
% (A) edge [loop right] node {} (A)
% (B) edge             node {} (A)
(C) edge             node {} (B)
(D) edge [bend right] node {} (A)
(E) edge [bend left]node {} (A)
(F) edge             node {} (A)
(A) edge             node {} (F)
(A) edge             node {} (C)
(C) edge             node {} (A)
(A) edge [bend right] node {} (D)
(A) edge [bend left]node {} (E);
% \node[below=7cm] at (current bounding box.base) {Overview of FPGA Implementation};
\end{tikzpicture}
}\caption{Overview of FPGA Implementation}\label{fig:fpga_implement}
\end{figure}
% \end{center}

For simplicity in verilog design, we fix the permuation map ($\pi(k)$) as the identity map and also store atmost three state variable values for a particular interval(i.e. for each character) during the encryption phase. As a result, we are require to search over $N_{c}$ for the interval index during decryption phase. To evaluate Eq. (5.1) we convert the RHS expression into postfix format and store the postfix expression in ROM. Then we evaluate the expression using the stack based postfix evaluation technique. Also the angle combinations of the sinusoidal terms present in the expressions are cached in LUT and appropriately decoded while evaluating the expression.  

\subsection{Memory \& Look Up Table (LUT)}
A number of LUTs are used for solving the differential equations by evaluating the postfix expressions in FPGA. These are :-

1. Angle Combinations

2. Parameters

3. State Variables 

4. Numeric constants

\begin{table}[!htb]
    \caption{LUT Details}
    \begin{subtable}{.5\linewidth}
      \centering
        \caption{}
        \begin{tabular}{|c|c|}
            \hline
                \textbf{Angle Combinations}  & \textbf{Value at t=0}\\
                \hline
                $2\theta_{1}-2\theta_{3} $ & $ 2.1124$\\
                $2\theta_{1}-2\theta_{2} $ & $ 1.4896$\\
                $\theta_{1}-\theta_{2} $ & $ 0.7448$\\
                $\theta_{1}+\theta_{2}-2\theta_{3} $ & $ 1.3676$\\
                $\theta_{1}-\theta_{3} $ & $ 1.0562$\\
                $\theta_{1}-2\theta_{2}+\theta_{3} $ & $ 0.4334$\\
                $\theta_{1} $ & $ 5.8229$\\
                $\theta_{1}-2\theta_{3} $ & $ -3.7105$\\
                $2\theta_{2}-2\theta_{3} $ & $ 0.6228$\\
                $\theta_{1}-2\theta_{2} $ & $ -4.3333$\\
                $\theta_{2} $ & $ 5.0781$\\
                $\theta_{2}-\theta_{3} $ & $ 0.3114$\\
                $2\theta_{1}-\theta_{2}-\theta_{3} $ & $ 1.801$\\
                $2\theta_{1}-\theta_{2} $ & $ 6.5677$\\
                $\theta_{2}-2\theta_{3} $ & $ -4.4553$\\
                $2\theta_{1}+\theta_{2}-2\theta_{3} $ & $ 7.1905$\\
                $\theta_{3} $ & $ 4.7667$\\
                $2\theta_{1}-\theta_{3} $ & $ 6.8791$\\
                $2\theta_{2}-\theta_{3} $ & $ 5.3895$\\
                $2\theta_{1}-2\theta_{2}+\theta_{3} $ & $ 6.2563 $\\ 
            \hline
        \end{tabular}
    \end{subtable}%
    \begin{subtable}{.5\linewidth}
      \centering
        \caption{}
        \begin{tabular}{|c|}
        \hline
            \textbf{Constants}\\
            \hline
            0\\
            1\\
            2\\
            3\\
            4\\
            6\\
            8\\
            12\\
            16\\
            24\\
            32\\
            48\\
            64\\
        \hline    
        \end{tabular}
    \end{subtable} 
\end{table}
\textbf{Postfix Evaluation:} The RHS expressions in the Eq.(5.1) are converted into postfix format. In the postfix expression, there are 4 types of terms:(1) Numeric constants ,(2) State Variable/Parameters, (3) Operations \& (4) Sinusoidal(sin or cos). Each such term are encoded to an 8-bit code. The entire postfix expression is stored in a LUT in coded format. During postfix evaluation these codes are decoded and the appropriate data value is fetched from the corresponding addresses. The meaning of the 8-bit encoding is shown below:\\
\begin{center}
\begin{bytefield}[bitwidth=2.2em]{8}
\bitheader{0-7} \\
\bitbox{2}{Type} & \bitbox{1}{T/A} & \bitbox{5}{Address/Op}
\end{bytefield}
\end{center}
Here, the first 2 bits, determines the type of term.

00 $\leftarrow$ Constants, 01 $\leftarrow$ Parameters, 10 $\leftarrow$ Sinusoidal, 11 $\leftarrow$ Operation\\
If first 2 bits are 01, check the next bit(T/A). If it is 0 then it is a parameter else state variable term. The rest 5 bits are address to the LUT (Fig. 5.2) for the corresponding state variable or parameter value in order.\\
If first 2 bits are 10, check the next bit(T/A). If it is 0 then it is a sine term else it is a cosine term. The rest 5 bits are address to the LUT (Table 5.1(a)) for the corresponding angle combination in order.\\
If first 2 bits are 11, check the last 3 bits. They denote the following:

000 $\leftarrow$ Exponentiation, 001 $\leftarrow$ Multiplication, 010 $\leftarrow$ Division,

011 $\leftarrow$ Addition \& 100 $\leftarrow$ Subtraction\\
Here addition and subtraction are handled similarly, only the sign bit is flipped for subtraction.\\
If the code is 0xff then it denotes the end of expression. For other cases, the last 6 bits denote address in LUT in order. All these decodings are done using the decoder modules or during term accumulation. 

\textbf{Stack:} A stack has been implemented using memory for evaluation of the poxtfix expressions. It consists of 2 immediate registers and stack memory. The immediate registers stores the top 2 values of the stack. Whenever an operation is detected in the expression, the operation is done on the 2 immediate registers and the result is stored in the 1st register. The other register is filled with the value popped from the top of the stack memory. Whenever a value is to be pushed into the stack, the value from the 2nd register is pushed to the memory, the value of 1st register to the 2nd register and the new value to the 1st register. And vice-versa for pop. 

\subsection{Arithmetic and Logic Unit (ALU)}
The Arithmetic and Logical Unit (ALU) has been appropriately parametrised to enable it to function at any given level of floating point precision (default format is IEEE-754). It consists of the following datapath units -

1. {\bf Addition Module} - This module performs floating point addition. The complete datapath has been split into 4 stages keeping in mind the target clock frequency 100 MHz. Current design contains 2 units of Addition Module.

2. {\bf Multiplication Module} - This module performs floating point multiplication. The complete multiplication datapath has been split into 5 stages in order to achieve the target clock frequency. Moreover, if required, the module can be configured to function in pipeline mode. Current design contains 1 unit of Multiplication Module.

3. {\bf Exponentiation Module} - This module evaluates the value of an input raised to an integer exponent. It utilises an instance of the multiplication module. Current design contains 1 unit of Exponentiation Module.

4. {\bf Division Module} - This module performs floating point division. The complete datapath has been split into multiple stages keeping in mind the target clock frequency 100 MHz. However, since, the division operation requires significantly more clock cycles compared to other operations, the design has been optimised to reduce the number of division oeration to minimum. Current design contains 1 unit of Division Module.

\begin{figure}[H]
\centering
\includegraphics[width=15cm]{schematic.png}
\caption{Schematic of multiplier module}\label{fig:schematic}
\end{figure}

\subsection{Control Unit}
The control unit of the implementation is essentially a Finite State Machine (FSM) which performs the required tasks in a well-defined sequence. In order to achieve an efficient implementation, the complete FSM has been factored into simpler state machines. A top-level FSM serves as control for these simpler FSMs. Basic description for these state machines is given as follows -

\subsubsection{Top-Level State Machine}

% \begin{center}
\begin{figure}[H]
\centering
\resizebox{10cm}{10cm}{
\begin{tikzpicture}[->,>=stealth',shorten >=2pt,auto,node distance=6cm, semithick]
  %\tikyle{every state}=[draw=none,text=black]

  \node[state] (A)                         {$DEFAULT$};
  \node[state] (B) [above left of=A]      {\begin{tabular}{c}$RECEIVE$\\$KEY$\end{tabular}};
  \node[state] (C) [right of=B]            {\begin{tabular}{c}$EVALUATE$\\$EXPRESSION$\end{tabular}};
  \node[state] (D) [below right of=C]      {\begin{tabular}{c}$MODIFY$\\$STATE$\\$VARIABLES$\end{tabular}};
  \node[state] (E) [below left of=D]       {\begin{tabular}{c}$OBTAIN$\\$CHAOTIC$\\$MAP$\end{tabular}};
  \node[state] (F) [left of = E]           {\begin{tabular}{c}$GENERATE$\\$CIPHERTEXT$\end{tabular}};
  %\node[state] (G) [left of = F]           {\begin{tabular}{c}$STORE$\\$CIPHERTEXT$\end{tabular}};

\path

(A) edge [loop right] node {} (A)
(B) edge             node {} (C)
(C) edge [bend left] node {} (D)
(D) edge [bend left] node {} (E)
(E) edge             node {} (F)
(F) edge [bend left] node {} (C)
(A) edge [bend left] node {} (B);
% \node[below=7cm] at (current bounding box.base) {Simplified form of Top-Level FSM};
\end{tikzpicture}
}\caption{Simplified form of Top-Level FSM}\label{fig:fsm_top}
\end{figure}
% \end{center}

% \begin{itemize}
% \item DEFAULT : Initial state of FSM after reset. Involves no processing.
% \item RECEIVE\_KEY : Involves receiving the encryption/decryption key values through USB or Ethernet interface.
% \item EVALUATE\_EXPRESSION : Evaluates the state-space expression using the given initial conditions for the chaotic dynamic system.
% \item MODIFY\_STATE\_VARIABLES : Updates the state variables based on the values obtained in previous state.
% \item OBTAIN\_CHAOTIC\_MAP : Evaluates a chaotic map through a linear combination of values of all state variable.
% \item GENERATE\_CIPHERTEXT : Generates the ciphertext for a particular plaintext string using the generated chaotic map.
% \end{itemize}

\begin{itemize}
\item DEFAULT : Initial state of FSM after reset. Involves no processing.
\item RECEIVE\_KEY : Involves receiving the encryption or decryption key values through USB or Ethernet interface.
\item EVALUATE\_EXPRESSION : Evaluates the state-space expression using the given initial conditions for the chaotic dynamic system. The processing begins in state STATE\_EXP\_EVAL\_BEGIN and the FSM waits for the complete signal \\(exp\_evaluator\_data\_ready) in state STATE\_EXP\_EVAL\_WAIT.
\item MODIFY\_STATE\_VARIABLES : Updates the state variables based on the values obtained in previous state. Involves updating the state variables using the values calculated in previous states.(theta\_dot(t+1) = theta\_dot(t) + theta\_dot\_dot(t)*deltaT, theta(t+1) = theta(t) + theta\_dot(t)*deltaT). Involves using the mult\_add module to perform these operations. This operation takes place across states \\ STATE\_POST\_PROCESS\_1, STATE\_POST\_PROCESS\_2, STATE\_MULT\_ADD\_WAIT.
\item OBTAIN\_CHAOTIC\_MAP : Evaluates a chaotic map through a linear combination of values of all state variable. Calculates the linear combination of theta, theta\_dot and theta\_dot\_dot. Currently, the value of theta itself corresponds to the chaotic map. Further, it calculates the intervals in which the value lies and adds it to corresponding addrss in LUT. This is done in state STATE\_POST\_PROCESS\_3, STATE\_POST\_PROCESS\_3\_WAIT, STATE\_ENCRYPT, STATE\_ENCRYPT\_STORE.
\item GENERATE\_CIPHERTEXT : Generates the ciphertext for a particular plaintext string using the generated chaotic map. Uses LUT to convert plaintext to ciphertext.
\end{itemize}

\subsubsection{Evaluate State-Space Expression}

% \begin{center}
\begin{figure}[H]
\centering
\resizebox{10cm}{10cm}{
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=6cm, semithick]
  %\tikyle{every state}=[draw=none,text=black]
    
  \node[state] (A)                         {$DEFAULT$};
  \node[state] (B) [above left of=A]      {\begin{tabular}{c}$FETCH$\\$INITIAL$\\$CONDITIONS$\end{tabular}};
  \node[state] (C) [right of=B]            {\begin{tabular}{c}$ANGLE$\\$COMBINATION$\\$CALC$\end{tabular}};
  \node[state] (D) [below right of=C]      {\begin{tabular}{c}$ANGLE$\\$NORMALIZATION$\end{tabular}};
  \node[state] (E) [below left of=D]       {\begin{tabular}{c}$POSTFIX$\\$TERM$\\$ACCUMULATE$\end{tabular}};
  \node[state] (F) [left of = E]           {\begin{tabular}{c}$STORE$\\$OUTPUT$\\$DATA$\end{tabular}};

\path

(A) edge [loop right] node {} (A)
(B) edge             node {} (C)
(C) edge [bend left] node {} (D)
(D) edge [bend left] node {} (E)
(E) edge             node {} (F)
(F) edge [bend left] node {} (A)
(A) edge [bend left] node {} (B);
% \node[below=7cm] at (current bounding box.base) {Simplified FSM of State-Space solver};
\end{tikzpicture}
}\caption{Simplified FSM of State-Space solver}\label{fig:fsm_state_space}
\end{figure}
% \end{center}


% \begin{itemize}
% \item DEFAULT : Initial state of FSM after reset. Involves no processing.
% \item FETCH\_INITIAL\_CONDITIONS : Involves fetching the required initial conditions from Block-RAM.
% \item ANGLE\_COMBINATION\_CALC : Create a cache containing frequently used linear combinations of state variables.
% \item ANGLE\_NORMALIZATION : Normalize the trigonometric inputs to the range $[-\pi, \pi]$.
% \item POSTFIX\_TERM\_ACCUMULATE : Evaluates the state-space expression stored in postfix form.
% \item STORE\_OUTPUT\_DATA : Store the values of state-space expression obtained in previous state to a Block-RAM .
% \end{itemize}

\begin{itemize}
\item DEFAULT : Initial state of FSM after reset. Involves no processing.
\item FETCH\_INITIAL\_CONDITIONS : Involves fetching the required initial conditions from Block-RAM. This includes STATE\_FETCH\_INIT\_VAL. Reads the theta and theta\_dot values from the BRAM mem\_state\_var in the top module.
\item ANGLE\_COMBINATION\_CALC : Create a cache containing frequently used linear combinations of state variables. Spans across STATE\_ANGLE\_COMB\_START (trigger the module) and STATE\_ANGLE\_COMB\_WAIT (wait for module to complete execution).
\item ANGLE\_NORMALIZATION : Normalize the trigonometric inputs to the range $[-\pi, \pi]$. Spans across STATE\_NORM\_ANGLE\_START (trigger the module) and STATE\_NORM\_ANGLE\_WAIT (wait for module to complete execution).
\item POSTFIX\_TERM\_ACCUMULATE : Evaluates the state-space expression stored in postfix form. Spans across STATE\_TERM\_ACC\_START (trigger the module) and STATE\_TERM\_ACC\_WAIT (wait for module to complete execution).
\item STORE\_OUTPUT\_DATA : Store the values of state-space expression obtained in previous state to a Block-RAM .
\end{itemize}

\subsubsection{Postfix Expression Evaluation}

% \begin{center}
\begin{figure}[H]
\centering
\resizebox{8cm}{8cm}{
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=6cm, semithick]
  %\tikyle{every state}=[draw=none,text=black]

  \node[state] (A)                         {$DEFAULT$};
  \node[state] (B) [above of=A]            {\begin{tabular}{c}$READ$\\$POSTFIX$\\$CODE$\end{tabular}};
  \node[state] (C) [right of=B]            {\begin{tabular}{c}$DATA\ OR$\\$OPERATOR?$\end{tabular}};
  \node[state] (D) [below of=C]            {\begin{tabular}{c}$PUSH$\\$DATA\ TO$\\$STACK$\end{tabular}};
  \node[state] (E) [above right of=C]      {\begin{tabular}{c}$OPERATE\ ON$\\$TOP\ TWO$\\$STACK\ VALUES$\end{tabular}};

\path

(A) edge [loop right] node {} (A)
(B) edge             node {code} (C)
(B) edge [bend left] node {eof} (A)
(C) edge [bend left] node {data} (D)
(C) edge [bend left] node {operator} (E)
(E) edge [bend left] node {} (D)
(D) edge [] node {} (B)
(A) edge [bend left] node {start} (B);
% \node[below=3cm] at (current bounding box.base) {Simplified FSM for Postfix Evaluator};
\end{tikzpicture}
}\caption{Simplified FSM for Postfix Evaluator}\label{fig:fsm_postfix}
\end{figure}
% \end{center}

% \begin{itemize}
% \item DEFAULT : Initial state of FSM after reset. Involves no processing.
% \item READ\_POSTFIX\_CODE : Fetch the code for the next term of postfix expression.
% \item DATA OR OPERATOR : Check if the code fetched corresponds to a data value or an operator.
% \item OPERATE\_ON\_TOP\_TWO\_STACK\_VALUES : Perform the corresponding operation of the two data values at stored at top of the stack.
% \item PUSH\_DATA\_TO\_STACK : Push the data value in postfix expression or the result of ALU operation onto the stack.
% \end{itemize}

\begin{itemize}
\item DEFAULT : Initial state of FSM after reset. Involves no processing.
\item READ\_POSTFIX\_CODE : Fetch the code for the next term of postfix expression from rams\_sp\_rom\_pfX(where X is 1/2/3).
\item DATA OR OPERATOR : Check if the code fetched corresponds to a data value or an operator. Takes place in STATE\_POSTFIX\_TERM\_READ.
\item OPERATE\_ON\_TOP\_TWO\_STACK\_VALUES : Perform the corresponding operation of the two data values at stored at top of the stack. Spans across STATE\_OPN\_START (trigger the module) and STATE\_OPN\_WAIT (wait for module to complete execution).
\item PUSH\_DATA\_TO\_STACK : Push the data value in postfix expression or the result of ALU operation onto the stack. STATE\_PUSH\_DATA\_DECODED pushes a data value from memory to stack. STATE\_PUSH\_DATA\_ALU pushes the result of operation to stack.
\end{itemize}


\section{Analysis}
\subsection{General Properties of the Cryptosystem}
\subsubsection{Test for Chaos}
There are some essential requirements that need to be obeyed by any chaos based cryptosystem. These requirements include:
\begin{enumerate}
	\item Sensitivity to Parametric values: It refers to the fact that a small perturbation in one of the system parameters is enough to make two trajectories, starting at the same initial point, diverge at exponential rate.
	\item Sensitivity to Initial  Condition:  Two  trajectories  starting  at  two  different  but  arbitrarily  close initial points diverge from each other at an exponential rate.
	\item Ergodicity:  Almost every trajectory tends toward an invariant distribution which is independent of the initial conditions, and almost every trajectory will eventually visit any arbitrary interval of arbitrary size.
\end{enumerate}

\begin{figure}[H]
\begin{subfigure}{0.5\textwidth}
\includegraphics[width=1\linewidth]{theta.jpg}
\caption{Variation of ${\theta}$ for ${m_{1}=0.2944}$}\label{fig:theta_comp}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\includegraphics[width=1\linewidth]{theta_near.jpg}
\caption{Variation of ${\theta}$ for ${m_{1}=0.294401}$}\label{fig:trajectory_near_comp}
\end{subfigure}
\caption{Plot showing Sensitivity to Parameter value ${m}$ with ${\Delta m = 10^{-6}}$}\label{fig:image6}
\end{figure}

\begin{figure}[H]
\begin{subfigure}{0.5\textwidth}
\includegraphics[width=1\linewidth]{theta.jpg}
\caption{Variation of ${\theta}$ for ${\theta_{1}(0)=-0.4603}$}\label{fig:theta_comp}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\includegraphics[width=1\linewidth]{theta_ch.jpg}
\caption{Variation of ${\theta}$ for ${\theta_{1}(0)=-0.460301}$}\label{fig:theta_ch_comp}
\end{subfigure}
\caption{Plot showing Sensitivity to Intital condition of ${\theta_{1}}$with ${\Delta \theta_{1} = 10^{-6}}$}\label{fig:image7}
\end{figure}

The proposed cryptosystem also holds such properties. The three qualities mentioned earlier are clearly evident from the plots and graphs shown Fig. 5.15 and Fig. 5.16. It is observed that keeping the parameters in one case and initial conditions in another case, constant leads to two completely different trajectories. Thus the map generated from the compound triple pendulum model possesses the essential chaotic properties to be employed in a general cryptosystem. 

\subsubsection{Collision Test}
Collision resistance is a property of cryptographic algorithms which makes it difficult to find two inputs which are encrypted to the same output. It must be ensured that finding collisions must be kept as hard as some of the hard mathematical problems like integer factorization  or discrete logarithm. Collision resistance does not mean that no collisions exist, it simply means that they are very hard to find. Here, we show that the proposed algorithm is fully collision resistant i.e. no collisions exist.

Since the entire range of $\hat{\textbf{y}}$ are partitioned according to the number of characters(say 256 i.e. $[\hat{y}_{min}+k\epsilon,\hat{y}_{min}+(k+1)\epsilon )$ for $k=0,1, ... , 255$), different characters are mappped to points in different intervals. Hence two different inputs having different characters are completely mapped to different intervals. So the encryption scheme is completely free of collisions. 

\subsubsection{Test for Randomness}
For testing randomness of the chaotic map, necessary statistical tests were applied. These statistical tests are generally employed for testing randomness in pseudo random number generators. Here, Diehard random number generator test suite has been used to do such tests. Developed by George Marsaglia, Diehard is a battery of tests which are used to determine the quality of PRNGs. The list of tests performed on the generated chaotic map data and the corresponding results obtained are shown in Table 5.2.

\begin{table}[h!]
\begin{center}
\caption{Dieharder Test}
\label{tab:table1}
\begin{tabular}{|c|c|c|c|c|c|} % <-- Alignments: 1st column left, 2nd middle and 3rd right, with vertical lines in between
    \hline
    \textbf{test\_name} & \textbf{ntup} & \textbf{tsamples} & \textbf{psamples} & \textbf{p-value} & \textbf{Assessment}\\
    \hline
    diehard\_birthdays &    0 &        100 &      100 & 0.98409924 &   PASSED \\  
    diehard\_operm5 &    0 &    1000000 &      100 & 0.02570841 &   PASSED \\  
    diehard\_rank\_32x32 &    0 &      40000 &      100 & 0.30314396 &   PASSED \\  
    diehard\_rank\_6x8 &    0 &     100000 &      100 & 0.07586247 &   PASSED \\  
    diehard\_bitstream &    0 &    2097152 &      100 & 0.83264505 &   PASSED \\  
    diehard\_opso &    0 &    2097152 &      100 & 0.93701062 &   PASSED \\  
    diehard\_oqso &    0 &    2097152 &      100 & 0.63759752 &   PASSED \\  
    diehard\_dna &    0 &    2097152 &      100 & 0.73795350 &   PASSED \\  
    diehard\_count\_1s\_str &    0 &     256000 &      100 & 0.77268562 &   PASSED \\  
    diehard\_count\_1s\_byt &    0 &     256000 &      100 & 0.55542008 &   PASSED \\  
    diehard\_parking\_lot &    0 &      12000 &      100 & 0.70977074 &   PASSED \\  
    diehard\_2dsphere &    2 &       8000 &      100 & 0.58428028 &   PASSED \\  
    diehard\_3dsphere &    3 &       4000 &      100 & 0.86446205 &   PASSED \\  
    diehard\_squeeze &    0 &     100000 &      100 & 0.19422339 &   PASSED \\  
    diehard\_sums &    0 &        100 &      100 & 0.33263813 &   PASSED \\  
    diehard\_runs &    0 &     100000 &      100 & 0.50609448 &   PASSED \\    
    diehard\_craps &    0 &     200000 &      100 & 0.36377661 &   PASSED \\   
    marsaglia\_tsang\_gcd &    0 &   10000000 &      100 & 0.66121444 &   PASSED \\ 
    sts\_monobit &    1 &     100000 &      100 & 0.31074688 &   PASSED \\  
    sts\_runs &    2 &     100000 &      100 & 0.98606705 &   PASSED \\  
    sts\_serial &    1 &     100000 &      100 & 0.23629469 &   PASSED \\  
    sts\_serial &    2 &     100000 &      100 & 0.85410639 &   PASSED \\  
    sts\_serial &    8 &     100000 &      100 & 0.11131795 &   PASSED \\  
    sts\_serial &   16 &     100000 &      100 & 0.83380616 &   PASSED \\  
    rgb\_bitdist &    1 &     100000 &      100 & 0.45061356 &   PASSED \\  
    rgb\_bitdist &    6 &     100000 &      100 & 0.53111009 &   PASSED \\   
    rgb\_bitdist &   12 &     100000 &      100 & 0.64865649 &   PASSED \\  
    rgb\_minimum\_distance &    2 &      10000 &     1000 & 0.41755433 &   PASSED \\   
    rgb\_minimum\_distance &    4 &      10000 &     1000 & 0.11298477 &   PASSED \\  
    rgb\_permutations &    2 &     100000 &      100 & 0.79654377 &   PASSED \\ 
    rgb\_permutations &    4 &     100000 &      100 & 0.85371565 &   PASSED \\  
    rgb\_lagged\_sum &    0 &    1000000 &      100 & 0.92039997 &   PASSED \\   
    rgb\_lagged\_sum &   16 &    1000000 &      100 & 0.78219023 &   PASSED \\   
    rgb\_lagged\_sum &   32 &    1000000 &      100 & 0.64955712 &   PASSED \\  
    rgb\_kstest\_test &    0 &      10000 &     1000 & 0.58005862 &   PASSED \\  
    dab\_bytedistrib &    0 &   51200000 &        1 & 0.01089458 &   PASSED \\  
    dab\_dct &  256 &      50000 &        1 & 0.06122408 &   PASSED \\  
    dab\_filltree &   32 &   15000000 &        1 & 0.12524761 &   PASSED \\   
    dab\_filltree2 &    0 &    5000000 &        1 & 0.50605989 &   PASSED \\  
    dab\_monobit2 &   12 &   65000000 &        1 & 0.27940682 &   PASSED \\  
        
    \hline
\end{tabular}
\end{center}
\end{table}

It is observed that in most of the tests, the chaotic map generator performs well. This can be attributed largely due to the non-linear dynamics of the map.

\subsection{Complexity Analysis}

In this report, we give an overview of the computational complexity of the algorithm both on software as well as hardware level.

\subsubsection{Setup Complexity}
Firstly, the computation of the state variable (${\theta}$) values for a time duration $t$ and time step $\Delta T$ requires $N$ iterations where $N= \frac{T}{\Delta t}$. In each iteration only 6 equations are solved for the 6 state variables ($\theta_{1}, \theta_{2}, \theta_{3}, \dot{\theta_{1}}, \dot{\theta_{2}}, \dot{\theta_{3}}$) each in $O(1)$ time. Thus the time required for generating the map is asymptotically $O(N)$. Here space complexity is also $O(N)$ for storing the state variable values. Secondly, Baptista type patitioning takes constant time if the range of the variables are already computed in the previous step. For assigning the variable values to the corresponding intervals, $O(N)$ time is required for each value. Thirdly, for encryption of a plaintext having $M$ characters, there would be $M$ iterations and in each iteration the encrypted value is randomly selected from the computed interval which takes constant time. So the time complexity for setup of the encryption module is $O(N)$ and $O(M)$ is the time complexity of processing each plaintext. Space complexity is still $O(N)$. Similarly, for decryption time complexity is also $O(N)$ and $O(M)$ for setup and processing respectively.\\
\textbf{Information Rate:} The information rate of any cryptosysytem is defined as the ratio of the size of plaintext to that of the cipher text. In our cryptosystem, we have
\begin{equation}
R = \frac{plaintext\ size}{ciphertext\ size} = \frac{8*M}{\ceil{\log_2N}*M} = \frac{8}{\ceil{\log_2N}}
\end{equation}
\subsubsection{Hardware Resource Utilization}
The following (Fig. 5.17) shows the resource utilization of the complete RTL implementation after synthesis using XST tool. The maximum resources used is in the storage of state variable values in the LUT. It is only about 1.3\% of the total fgpa memory and hence the memory usage is quite low. It can be seen that 1726 LUTs and 1883 Flip-Flops are required. Also, due to target device being FPGA, instances of DSP48 have been used.
\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{table.png}
\caption{Table showing Resource Utilization}\label{fig:table}
\end{figure}

% \begin{figure}[H]
% \centering
% \includegraphics[width=0.4\linewidth]{graph.png}
% \caption{Bar graph showing Resource Utilization}\label{fig:graph}
% \end{figure}

\subsection{Reason for being Quantum-Safe}
The argument in regards to the quantum-safe property of this algorithm is due to its innate chaotic nature. Traditional Shor's and Glover's algorithms cannot break this system as they deal with a different paradigm of hard problems like integer factorization and discrete logarithm. Also the highly non-linear and interdependent nature of the dynamical system makes it difficult for even the quantum algorithms to do brute force attacks without the total or partial knowledge of key. Even with partial knowledge of key values, it is useless to do brute force attacks as the chaotic maps are highly sensitive to key values. The key size is about $21\times(32 bits) = 672 bits$ for single precision arithmetic which is quite large enough. All these reasons direct us to be confidently stand by this algorithms and call it quantum computing immune. 
